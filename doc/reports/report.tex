%% TeXworks instructions:
% !TeX root = ./report.tex
% !TEX encoding = UTF-8 Unicode
%% !TEX program = arara
%% !TEX TS-program = arara
% !TeX spellcheck = it-IT

% arara: pdflatex: { synctex: yes, action: batchmode, options: "-halt-on-error -file-line-error-style" }
% arara: pdflatex: { synctex: yes, action: nonstopmode, options: "-halt-on-error -file-line-error-style" }

%% Generate a report.xmpdata file with title and authors for PDF/A-compliant format %%
\begin{filecontents*}{\jobname.xmpdata}
    \Title{Maraph1-mp Project Report}
    \Author{Nicholas Brasini\sep Gjulio Jakova\sep Federico Naldini\sep Jacopo Riciputi}
\end{filecontents*}

\documentclass[%
    a4paper,            % specifica il formato A4 (default: letter)
    10pt,               % specifica la dimensione del carattere a 10
    oneside,            % serve per impaginare per stampa solo fronte
    notitlepage         % mette il titolo in una pagina separata (solo per article)
]{article}

\usepackage{a4wide}             % consente di avere più spazio nell'A4

%% ORDINE IMPORTANTE INIZIO %%%%%%%%%%%%
\usepackage[T1]{fontenc}        % serve per impostare la codifica di output del font
\usepackage{textcomp}           % serve per fornire supporto ai Text Companion fonts
\usepackage[utf8]{inputenc}     % serve per impostare la codifica di input del font
\usepackage[
    english,            % utilizza l'inglese come lingua secondaria
    italian             % utilizza l'italiano come lingua primaria
]{babel}                        % serve per scrivere Indice, Capitolo, etc in Italiano

\usepackage{lmodern}            % carica una variante Latin Modern prodotto dal GUST
%% ORDINE IMPORTANTE FINE %%%%%%%%%%%%%%

\usepackage{indentfirst}        % serve per avere l'indentazione nel primo paragrafo
\usepackage{setspace}           % serve a fornire comandi di interlinea standard
\usepackage{xcolor}             % serve per la gestione dei colori nel testo
\usepackage{graphicx}           % serve per includere immagini e grafici
\usepackage{float}
\setcounter{figure}{0}
\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}} % serve a cambiare la didascalia dell'immagine basandosi sulla sezione in cui è chiamata

\graphicspath{{./images/}}

\usepackage[%
    strict,             % rende tutti gli warning degli errori
    autostyle,          % imposta lo stile in base al linguaggio specificato in babel
    english=american,   % imposta lo stile per l'inglese
    italian=guillemets  % imposta lo stile per l'italiano
]{csquotes}                     % serve a impostare lo stile delle virgolette

\usepackage{multirow}           % aggiunge la possibilità di raggruppare celle su più righe nelle tabelle

\onehalfspacing%                % Imposta interlinea a 1,5 ed equivale a \linespread{1,5}

\setcounter{secnumdepth}{4}     % Numera fino alla sottosezione nel corpo del testo
\setcounter{tocdepth}{4}        % Numera fino alla sotto-sottosezione nell'indice

\usepackage[%
    depth=3,            % equivale a bookmarksdepth di hyperref
    open=false,         % equivale a bookmarksopen di hyperref
    numbered=true       % equivale a bookmarksnumbered di hyperref
]{bookmark}                     % Gestisce i segnalibri meglio di hyperref
\usepackage{hyperref}           % Gestisce tutte le cose ipertestuali del pdf
\hypersetup{%
    pdfpagemode={UseNone},
    hidelinks,          % nasconde i collegamenti (non vengono quadrettati)
    hypertexnames=false,
    linktoc=all,        % inserisce i link nell'indice
    unicode=true,       % only Latin characters in Acrobat’s bookmarks
    pdftoolbar=false,   % show Acrobat’s toolbar?
    pdfmenubar=false,   % show Acrobat’s menu?
    plainpages=false,
    breaklinks,
    pdfstartview={Fit},
    pdfauthor={Nicholas Brasini, Gjulio Jakova, Federico Naldini, Jacopo Riciputi},
    pdfcreator={Nicholas Brasini, Gjulio Jakova, Federico Naldini, Jacopo Riciputi},
    pdftitle={Maraph1-mp Project Report},
    pdflang={it}
}
\usepackage[utf8]{inputenc} % serve per avere l'indice di tutti i capitoli all'inizio

%\usepackage[a-1b]{pdfx}
\usepackage[%
    english,italian,    % definizione delle lingue da usare
    nameinlink          % inserisce i link nei riferimenti
]{cleveref}                     % permette di usare riferimenti migliori dei \ref e dei varioref

\title{\LARGE{\textbf{Maraph1-mp Project Report}}}

\author{%
    Nicholas~Brasini\\%
    Gjulio~Jakova\\%
    Federico~Naldini\\%
    Jacopo~Riciputi
}

\date{%
    \small{Paradigmi di Programmazione e Sviluppo}\\%
    \small{Anni accademici 2017--2018 e 2018--2019}
}


\begin{document}

    \maketitle
    \clearpage
	\tableofcontents
	\clearpage
	\setcounter{figure}{0}
    \section*{\Huge {Capitolo 1}\label{chapter1}}
      \section{Processo di sviluppo}\label{sec:process}
        \subsection {Metodologia di sviluppo}\label{subsec:metodology}
        \subsection {Strumenti adottati}\label{subsec:tools}

        \clearpage

	\setcounter{figure}{0}
    \section*{\Huge {\textbf Capitolo 2}\label{chapter2}}
    \section{Requisiti}\label{sec:requirements}
         \subsection {Requisiti utente}\label{subsec:requirements:business}
             \subsection {Requisiti funzionali}\label{subsec:requirements:functional}
            \subsubsection[Gioco]{\large {Regole del gioco}\label{subsub:requirements:game}}
            \subsubsection[NoAutenticazion]{\large {Servizio di gioco senza autenticazione}\label{subsub:requirements:noauth}}
            \subsubsection[Autenticazion]{\large {Servizio di gioco con autenticazione}\label{subsub:requirements:auth}}
            \subsubsection[Stanze di gioco]{\large {Servizio delle stanze di gioco}\label{subsub:requirements:lobby}}
            \subsubsection[Interfaccia utente]{\large {Interfaccia grafica per l'utente}\label{subsub:requirements:gui}}
        \subsection {Requisiti non funzionali}\label{subsec:requirements:notFunctional}
        \subsection {Requisiti implementativi}\label{subsec:requirements:implementative}

   \clearpage

    \setcounter{figure}{0}
    \section{Design architetturale}\label{sec:design}
        \subsection[Architettura]{Architettura e pattern utilizzati}\label{subsec:architecture}
            \subsubsection{Architettura server-side}\label{subsub:architecture:server}
            \subsubsection{Architettura client-side}\label{subsub:architecture:client}
        \subsection{Tecnologie}\label{subsec:technologies}

        \clearpage

    \section{Design di dettaglio}\label{sec:details}

	In questa sezione saranno presentate le scelte effettuate a livello di design nel dettagio. In primo luogo si tratterà dell'organizzazione generale del codice in \texttt{packages} e dei \textit{design patterns} applicati più frequentemente, successivamente saranno analizzati nel particolare le principali funzionalità e classi di ogni modulo del sistema.

    \subsection {Organizzazione del codice}\label{subsec:details:codestructure}
    La struttura del progetto si presenta divisa in cinque \texttt{packages} principali, tre di questi corrispondono perfettamente ai componenti portanti dell'architettura distribuita del sistema, i restanti due sono stati pensati come unità di supporto alle strutture principali.

    \begin{itemize}
    \item{\texttt{client:}} All'interno del \texttt{package} client viene modellata l'interazione tra un utente fruitore del gioco e
    l'architettura remota del sistema, sono presenti quindi tutte le classi necessarie alla realizzazione dell'interfaccia grafica, al supporto delle funzionalità lato client di gioco, ricerca e aggiunta di un amico, replay e visualizzazione in tempo reale di una partita.


    \item{\textbf{\texttt{discovery:}}}
      Questo \texttt{package} contiene tutti i sorgenti relativi all'implementazione del \textit{discovery server},
      componente centralizzato che espone un servizio di pagine gialle, mantenendo traccia di tutti i \textit{server} attivi
      all'interno del sistema, nonché di tutte le partite che stanno venendo disputate e dei giocatori online.

    \item{\texttt{server:}}
      Il \texttt{package} server comprende i file necessari alla realizzazione un server backend per gestire le partite,
      il login e la registrazione degli utenti, il salvataggio in remoto dei punteggi e delle partite.

    \item{\texttt{commons:}}
      Uno dei due \texttt{packages} di supporto: contiene un insieme di classi e oggetti di \textit{utilities} comuni agli altri \texttt{packages} del sistema.

    \item{\texttt{core:}}
      Il secondo \texttt{package} che non corrisponde direttamente a un elemento dell'architettura distribuita: contiene il cuore del sistema, ovvero l'implementazione delle regole e logiche di gioco di Marafone; nonostante potesse essere inserito all'interno di uno degli altri \texttt{packages}, si è scelto di mantenerlo separato, in quanto contenente un'insieme di classi ed oggetti ad alto valore per il sistema.

  \end{itemize}

  \subsection {Pattern di progettazione generali}\label{subsec:details:generaldesingpattern}
  Durante l'intero processo di sviluppo e integrazione sono stati impiegati diversi \textit{desing patterns}, tra questi alcuni si sono prestati meglio di altri a un applicazione costante e ripetuta all'interno di varie strutture.\\
  Il primo e più utilizzato tra tutti i \textit{patterns} è stato sicuramente il \texttt{Factory Method}: avendo infatti deciso di utilizzare
  il linguaggio di Programmazione \textit{Scala} come principale linguaggio impiegato all'interno del progetto, è venuto abbastanza naturale adattare il processo di definizione dei metodi di una classe UML alla generazione di un \texttt{trait} e di realizzare la sua implementazione con una classe privata dichiarata all'interno del \texttt{Companion Object} di tale trait, mettendo a disposizione il metodo \texttt{apply()} di tale oggetto come \texttt{Factory Method} per le istanze della classe.
  Un altro pattern decisamente impiegato è stato \texttt{Strategy}, grazie all'approccio orientato al paradigma funzionale di \textit{Scala}, è venuto molto naturale definire classi e strutture che isolassero alcuni algoritmi necessari per il loro funzionamento e permettessero di definirli dinamicamente.
  Infine è utile citare, sebbene non ricada strettamente in all'interno di una specifica categoria di \textit{design patterns}, la scelta di progettazione effettuata nel realizzare insiemi di oggetti statici: invece di utilizzare una struttura basata sulle enumerazioni, si è deciso di sfruttare i costrutti messi a disposizione dal linguaggio scala, ottenendo una soluzione composta da un \texttt{trait} che definisse il contratto da rispettare e una serie di \texttt{case objects} estendenti il \texttt{trait} in questione.

  \subsection {Core}\label{subsec:details:core}
  Punto di partenza per il design del sistema è stata la descrizione delle funzionalità e componenti necessarie allo svolgimento di una partita di Marafone, come mostrato dal relativo diagramma delle classi nella figura 4.1.

\begin{figure}[H]
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{initialArchitecture}
   \caption{diagramma delle classi relativo allo svolgimento di una partita}
\end{figure}

 E' importante sottolineare che tale diagramma rappresenta una visione di alto livello del sistema dal punto di vista esclusivamente della modellazione di una partita, non catturando in nessun modo caratteristiche legate ad altri domini quali la separazione del sistema secondo un modello distribuito, tuttavia posto che alcuni elementi sarebbero stati realizzati mettendo in gioco scelte di design piuttosto complesse, il modello fornito dallo schema risultava nel complesso abbastanza solido.
 Come è possibile notare, lo schema si struttura seguendo il pattern di progettazione \textit{MVC}, dove i componenti soggetti a una maggiore complessità risultano sicuramente controller e view, mentre model risulta più solido e definito.
 Di conseguenza si è scelto di catturare all'interno del \texttt{package core} la componente di modello della partita, identificandone i principali componenti:

\begin{itemize}
  \item{\texttt{mazzo di gioco:}} all'interno del package \texttt{deck} sono presenti tutte le strutture e funzionalità necessarie alla gestione del mazzo di gioco, come ad esempio la divisione delle carte nelle mani dei giocatori e il mescolamento delle stesse all'interno del mazzo; viene definita inoltre la struttura necessaria per la registrazione e calcolo del punteggio durante la partita.


  \item{\texttt{ciclo di gioco:}} il package \texttt{game} contiene l'insieme delle regole e procedure che regolano una partita tra quattro giocatori, definendo inoltre i concetti di set, team e match.

  \item{\texttt{giocatore:}} definisce il concetto di giocatore e le operazioni possibili da parte di quest'ultimo.

\end{itemize}

  Per quanto riguarda le funzionalità di controller e gui, esse sono state realizzate all'interno di core in un primo momento, ma sono poi state integrate in altri moduli.

\subsection {Discovery}\label{subsec:details:discovery}
All'interno del \texttt{package discovery} si è realizzato il servizio di discovery, seguendo i requisiti e le specifiche definite in fase di progettazione dell'architettura distribuita.\\
In quanto elemento unico e comune a tutta l'architettura, il discovery server svolge le funzioni di un registro centralizzato, consultabile e aggiornabile da ogni altro componente del sistema, tale registro deve mantenere quindi i riferimenti ai server online, il numero di partite al momento disputate all'interno del sistema, un loro identificativo e il server su cui sono eseguite, inoltre tiene traccia dei giocatori online che hanno effettuato il login, fornendo la possibilità agli altri utenti registrati nel sistema di contattarli.
Mostrato nella figura 4.2, è possibile vedere il diagramma delle classi relativo al \texttt{package discovery}

 \begin{figure}[H]
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{discoveryArchitecture}
   \caption{diagramma delle classi relativo alla struttura del discovery}
  \end{figure}

Tale diagramma presenta una classe al centro \texttt{DiscoveryServer} e tre classi in relazione di associazione con essa.
La prima tra queste è \texttt{MatchesSet}, classe che mette a disposizione una semplice struttura per gestire all'interno del discovery l'insieme delle partite giocate in tempo reale, salvandone l'identificatore.\\
Successivamente \texttt{RegistryActor} realizza un wrapper tra \texttt{DiscoveryServer e SocialActorsMap}, tale attore si occupa di esporre un punto di comunicazione per l'aggiornamento di un registro condiviso contenente tutti gli identificatori dei giocatori registrati al momento online.\\ \texttt{RegistryActor} comunica con tutti i \texttt{SocialActor} in esecuzione sui vari client presenti all'interno del sistema mediante il protocollo \textit{Publish-Subscribe} messo a disposizione dalla libreria \textit{Akka cluster}, ricevendo richieste di registrazione e rimozione di utenti e pubblicando una versione aggiornata del registro sul canale ad ogni aggiornamento.\\
In secondo luogo è presente \texttt{SocialActorsMap}: tale classe incarna una struttura praticamente analoga a \texttt{MatchesSet}, con l'unica differenza di gestire il riferimento ai giocatori online invece che alle partite.\\
Infine \texttt{ServerMap} gestisce l'elenco dei server disponibili, tenendo conto anche del numero di partite disputato sopra di esse.\\
Elemento chiave per l'intero \texttt{package} è sicuramente \texttt{DiscoveryServer}, classe che realizza l'implementazione di un server web ,estendendo la classe \texttt{Verticle} della libreria \textit{Vertx}, e delle \textit{REST API} necessarie per contattarlo.
Menzione particolare meritano le \textit{REST API}, sviluppate come \texttt{case objects} estendenti un \texttt{trait} chiamato \texttt{RestAPI}, presente nel \texttt{package commons}. Il contratto definito da tale \texttt{trait} vincola ogni oggetto a implementare tre metodi fondamentali per il funzionamento di ogni api:
\begin{itemize}
  \item{\texttt{path:}} definisce il path necessario per richiamare la \textit{REST API} all'interno del server su cui viene esposta.

  \item{\texttt{httpMethod:}} specifica la richiesta http con cui deve essere effettuata la chiamata alla \textit{REST API}.

  \item{\texttt{asRequest:}} crea un oggetto della classe \texttt{Request} a partire dalla \textit{REST API}, tale classe consente di specificare tramite uno \texttt{strategy method} le operazioni da eseguire quando viene ricevuta una richiesta corrispondente all'API in questione.
\end{itemize}

Questa progettazione delle \textit{REST API} consente un aggiunta dinamica e facile di nuove API a quelle già presenti, per aggiungere una nuova API al discovery server non occorre fare altro che definire un oggetto estendente il trait \texttt{DiscoveryAPI} e un handler per la richiesta generata da tale API all'interno del metodo \texttt{deployAPI()}
Le API attualmente presenti su discovery sono le seguenti:

\begin{itemize}
  \item{\texttt{RegisterServer:}} registra un server all'interno del discovery.

  \item{\texttt{GetServer:}} API chiamata da client, restituisce il server su cui al momento, sono attive meno partite, implementando così una basilare forma di \textit{load balance} all'interno del sistema.

  \item{\texttt{RegisterMatch:}} API chiamata da un server, registra l'id di una nuova partita sul discovery e aggiorna il contatore delle partite in corso relative al singolo server.

  \item{\texttt{RemoveMatch:}} API chiamata da un server, notifica al discovery la fine di una partita, rimuovendo il suo id dal discovery e aggiornando il contatore relativo al server.

  \item{\texttt{RegisterSocialID:}} API chiamata da un client dopo la fase di autenticazione, notifica a \texttt{RegistryActor} la presenza di un nuovo subscriber da contattare.
\end{itemize}

Oltre all'esposizione delle seguenti API, il discovery ha anche il compito di mettere in esecuzione i \textit{seed nodes} necessari per \textit{Akka cluster}, si è scelto infatti di posizionare i \textit{seed nodes}, ovvero due \texttt{ActorSystem} che fungono da \textit{entry points} all'interno del sistema cluster, sopra lo stesso host in cui viene messo in esecuzione il server, così da accentuare ulteriormente il carattere centralizzato del discovery server.\\
 Tali \texttt{ActorSystem} vengono generati tramite il metodo di \texttt{DiscoveryServer} \texttt{startDiscoveryCluster()}, che dato l'indirizzo ip della macchina su cui viene messo in esecuzione il discovery server, costruisce due \texttt{ActorSystem} sulle porte 2551 e 2552 che creano la struttura di cluster al cui interno si andranno a inserire gli \textit{ActorSystem} in esecuzione sui vari client e server.

 \subsection {Server}\label{subsec:details:server}
 Questo è il modulo contenente tutto il codice necessario a mettere in esecuzione un server backend. Le funzionalità esposte da questo struttura sono creazione e gestione di varie partite, competitive o meno, registrazione e autenticazione di utenti, salvataggio e recupero di partite terminate.Oltre a queste operazioni che rispondono direttamente a una richiesta di un utente, sono presenti anche tutta una serie di procedure per la comunicazione con il discovery server, in modo da mantenere aggiornato sempre lo stato di quest'ultimo con lo stato effettivo del sistema.\\
 Ogni server è pensato per essere indipendente dagli altri, delegando le politiche di selezione e divisione del lavoro al discovery Server:
 E' infatti importante notare che ogni client non contatta uno specifico host al momento dell'avvio, ma invia una richiesta al discovery server, il quale provvederà a assegnargli uno tra i server con minor numero di partite al momento disputate; questa scelta ci è parsa ragionevole in quanto il numero di partite al momento effettuate poteva fornire un primo, per quanto instabile, indice di carico computazionale del singolo server, di conseguenza andare a selezionare di volta in volta un server diverso per ogni client che si univa al sistema poteva essere un semplice, seppur rozzo, meccanismo di \textit{load balance} all'intero del sistema.\\
 La figura 4.3 riassume efficacemente i passaggi che portano all'esecuzione di una chiamata REST all'interno di un server da parte di un client.\\

 \begin{figure}[H]
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{restAPICall}
    \caption{diagramma di sequenza relativo all'esecuzione di una chiamata REST da parte di un client}
 \end{figure}

 Queste modalità comunicative sono utilizzate per tutte le interazioni tra client e server, fatta eccezione per le comunicazioni durante la partita, in tale frangente abbiamo scelto di affidarci alla comunicazione real time tra attori tramite messaggi end to end e il protocollo \textit{publish subscribe} messo a disposizione da \textit{Akka cluster}.
 Principale e più importante funzionalità del server è la creazione, gestione, distruzione delle varie istanze di partite in gioco:
 alla chiamata di una specifica \textit{REST API}, chiamata \texttt{FoundGameAPI}, viene avviato il processo di ricerca per una nuova partita; per prima cosa vengono estrapolati dall'interno della richiesta REST il nome utente del giocatore che l'ha inviata e eventuali nomi di avversari/compagni, tali dati vengono poi spediti a un attore, \texttt{LobbyActor} con il compito di gestire la lista delle lobby, ovvero delle partite di gioco con numero di giocatori insufficienti a iniziare una nuova partita; \texttt{LobbyActor} esegue una ricerca tra le proprie lobby e  nel caso tra queste ve ne sia una che può ospitare tutti i giocatori estratti dalla richiesta, allora essi sono aggiunti a tale lobby, altrimenti viene creata una nuova lobby; terminata questa operazione, all'utente viene notificato l'identificatore della lobby in cui è stato inserito come risposta REST alla sua richiesta. \\
 Nel momento in cui una lobby raggiunge il numero massimo di giocatori viene dato il via a una nuova partita:in primo luogo il server notifica al discovery l'incremento del numero di partite in esecuzione, successivamente viene creato un attore di classe \texttt{GameActor} a cui vengono passati gli identificatori dei quattro giocatori che prenderanno parte alla partita, tale attore ha il compito di gestire lato server la partita, andando a fornire per ogni giocatore le sue carte, applicando le regole per la selezione della briscola, delle prese di gioco, del punteggio e così via.\\
 Come affermato sopra, le comunicazioni durante la partita avvengono tramite scambio di messaggi tra il \texttt{GameActor} e gli attori dei quattro giocatori, in particolare \texttt{GameActor} pubblica messaggi su un canale a cui gli altri quattro attori sono iscritti, mentre riceve messaggi spediti dal singolo attore.
 Al momento della fine di una partita, il server si occupa di registrarla su un database remoto, di aggiornare il discovery e cancellare la lobby dalla propria lista interna.\\
 Descritte le modalità di gestione delle partite, tutti gli altri servizi presenti sul database sono di ricerca e/o aggiunta di nuovi dati a un database backend, tramite un meccanismo a \textit{REST API}, di seguito è riportato l'elenco delle principali \textit{API} sviluppate all'interno del server:
 \begin{itemize}
   \item{\texttt{FoundGame:}} comincia la ricerca di una partita secondo le modalità sopra descritte, la richiesta di questa API può contenere al suo interno da uno a quattro username e un flag che specifica se si richiede di giocare una partita competitiva o meno.

   \item{\texttt{AddUser:}} registra un nuovo utente sul database backend con le credenziali specificate nella richiesta.

   \item{\texttt{LoginUser:}} controlla se le credenziali fornite da un utente durante il login corrispondono a quelle salvate all'interno del database.

   \item{\texttt{GetUser:}} recupera dal database i dati relativi a un utente,tra cui il punteggio attuale dell'utente.

   \item{\texttt{AddFriend:}} aggiunge alla lista degli amici dell'utente che effettua la richiesta un nuovo amico.

    \item{\texttt{GameRest:}} recupera dal database una partita registrata.

    \item{\texttt{GetFriends:}} recupera dal database la lista degli amici dell'utente che effettua la richiesta.
 \end{itemize}

 Ognuna di queste API fa riferimento a un oggetto della classe \texttt{RedisUserUtils} che si occupa di generare, gestire e recuperare il risultato delle queries necessarie allo svolgimento delle operazioni richieste.

  \subsection {Client}\label{subsec:details:client}
  Tra tutti i \texttt{packages} del progetto, sicuramente \texttt{Client} risulta quello più complesso e articolato.Nonostante discovery e server catturino una buona parte della complessità dei requisiti del sistema, una parte altrettanto grande, se non maggiore è delegata a questo modulo.\\
  \texttt{Client} si pone il difficile compito di offrire all'utente fruitore del gioco tutte le funzionalità da lui attese gratificandolo con una valida \textit{User experience} e mascherando il più possibile la complessità dovuta all'integrazione e supporto alle altre componenti del sistema.

  \begin{figure}[H]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{clientArchitecture}
     \caption{diagramma delle classi relativo al package client}
  \end{figure}

La figura 4.4 mostra appieno la complessità presente all'interno di client, sebbene il diagramma rimanga comunque una vista di alto livello sul sistema, il numero delle classi e relazioni in gioco e sicuramente superiore a qualunque altro componente del sistema.
Come è possibile evincere da tale figura, l'architettura di questo modulo è stata pensata basandosi sul classico modello di progettazione MVC, riadattato per essere il più possibile scalato all'interno dell'organizzazione del modulo: tale pattern non è applicato solamente alla macro struttura dello schema, ma si ripete all'interno dei vari spaccati del diagramma.
Nella parte alta dello schema viene rappresentato il centro di tutta la struttura, identificato dalle classi \texttt{GUI, ClientController} e \texttt{RestWebClient}, questo nucleo funge da nodo centrale per le comunicazioni e interazioni che avvengono all'interno del client, inoltre realizza le funzionalità di registrazione, autenticazione e di accesso come utente anonimo.\\
Per quanto concerne le funzionalità di partita e social dell'applicativo, abbiamo pensato di definire due sottomoduli, entrambi collegati al nucleo della struttura, che condividevano la stessa architettura di fondo, composta da un componente grafico, un attore estendente l'interfaccia \texttt{ModelActor} come modello capace di comunicazione remota e un oggetto della classe \texttt{ActorController} per fungere da mediatore tra le altre due entità: per quanto riguarda il lato social, \texttt{SocialGUI}, \texttt{SocialController} e \texttt{SocialActor} sono le classi di riferimento, mentre per la gestione della partita, sia essa giocata, seguita come spettatore oppure riprodotta \texttt{MatchGUI}, \texttt{MatchController} e \texttt{MatchActor} incarnano la struttura sopra descritta.\\
Rimane da analizzare solamente \texttt{RestWebClient}, questa classe si occupa dell'esecuzione delle chiamate REST, possiede due diverse implementazioni che permettono di chiamare API differenti tra loro.
Terminata l'analisi statica delle classi di modello, verranno ora descritti il comportamento generale e le interazioni principali delle entità presenti nel modulo client:\\ 
All'avvio dell'applicativo, viene aperta una finestra di login collegata a un'istanza di \texttt{ClientController}, da questa schermata l'utente potrà accedere se dispone già di un account, registrarsi oppure continuare senza effettuare nessun operazione di autenticazione, in quest'ultimo caso il controllo rimarrà all'oggetto \texttt{ClientController}, altrimenti passerà a un oggetto \texttt{SocialController}. Nel caso in cui l'utente scelga di continuare senza registrarsi, sarà possibile, tramite appositi pulsanti, richiedere di giocare una partita o di prendervi parte come spettatore: in entrambi i casi il controller istanzierà un nuovo attore di classe \texttt{MatchActor}, tramite l'oggetto \texttt{MatchController} al suo interno, a cui verrà passato l'identificatore della partita a cui prendere parte/ seguire, successivamente \texttt{MatchController} andrà a eseguire il caricamento della nuova finestra di gioco.
In caso di Login/Registrazione invece \texttt{ClientController} creerà un oggetto di classe \texttt{SocialController} e il corrispondente \texttt{SocialActor}, tale attore durante la creazione andrà a contattare il registro remoto su discovery per ottenere la lista di giocatori online, nel frattempo il controller recupererà la lista di tutti gli amici registrati tramite una chiamata REST al server assegnato. Un utente registrato avrà accesso a una schermata contenente diverse funzionalità: oltre a quelle già citate per l'utente anonimo, che verranno delegate da \texttt{SocialController} a \texttt{ClientController}, il giocatore registrato potrà contattare i giocatori online e i propri amici tramite uno scambio di messaggi tra i relativi \texttt{SocialActors}, grazie a tali interazioni sarà possibile aggiungere nuovi amici e formare team di gioco per le partite; sarà inoltre a disposizione una modalità di ricerca e riproduzione delle partite registrate, tale funzionalità viene resa possibile grazie a una combinazione di chiamate REST e delegazioni a \texttt{ClientController}, che provvede a settare il proprio \texttt{MatchController} come entità responsabile alla riproduzione della partita.    
  
\clearpage

	\setcounter{figure}{0}
    \section{Implementazione}\label{sec:implementation}
        \subsection{Nicholas Brasini}\label{subsec:brasini}
        \subsection{Gjulio Jakova}\label{subsec:jakova}
        \subsection{Federico Naldini}\label{subsec:naldini}
All'interno del progetto Maraph1-mp, mi sono occupato delle seguenti parti:
\begin{itemize}
	\item{\textbf{Generale}}
	 \begin{itemize}
	 	\item Configurazione di Gradle.
	 	\item Configurazione di Scoverage.
	 	\item Configurazione del parser CLI.
	 \end{itemize}

\item{\textbf{Core}}
\begin{itemize}
	\item Design e implementazione delle carte.
	\item Definizione del concetto di mazzo.
\end{itemize}

\item{\textbf{Discovery}}
\begin{itemize}
	\item Design di dettaglio del discovery server.
	\item Definizione e sviluppo della classe \texttt{DiscoveryServer}
	\item Creazione delle strutture di supporto.
\end{itemize}

\item{\textbf{Client}}
\begin{itemize}
	\item Design di dettaglio dell'architettura client.
	\item Creazione e implementazione di \texttt{RestWebClient}
	\item Creazione e implementazione di \texttt{Generic Controller}
	\item Design, creazione e implementazione degli aspetti legati alle funzionalità social.
	\item Gestione della creazione e scambio di schermate all'interno della GUI.
\end{itemize}

\end{itemize}

\subsubsection{\textbf{Generale}}
Soprattutto nel primo sprint, mi sono occupato della configurazione generale del progetto, andando a definire quali sarebbero stati i principali strumenti utilizzati a supporto della progettazione.
Abbiamo scelto di utilizzare \textit{Git} come tecnologia di controllo versione, appoggiandoci a un repository remoto su \textit{Github}, di conseguenza è venuta naturale la scelta nell' utilizzare \textit{GitFlow} come modello di flusso di sviluppo, grazie anche alla presenza di valide estensioni per i principali IDE.
Per quanto riguarda poi la configurazione di \textit{Gradle}, essa è stata portata avanti in maniera iterativa durante tutto lo svolgimento del progetto, le uniche difficoltà incontrate sono state relative alla configurazione del plugin \textit{SCoverage}, che è risultato particolarmente ostico da far eseguire direttamente dai tasks messi a disposizione da \textit{Gradle}
Come libreria principale di testing, è stata configurata \textit{Scalatest}: questa scelta è dovuta a una maggiore familiarità con le modalità di test messe a disposizione da tale suit, ho portato però avanti anche sperimentazioni con un altra libreria di testing, ovvero \textit{ScalaCheck}, tuttavia nonostante le grandi potenzialità di tale suit, l'integrazione col plugin SCoverage risultava complessa e non banale, di conseguenza abbiamo scelto di scartare la libreria.
Infine mi sono occupato della ricerca e configurazione di una libreria per il parsing dei comandi \textit{command line interface}, necessari per la configurazione dei vari server e clients, scegliendo infine \href{https://github.com/scallop/scallop}{\textit{Scallop}}, libreria realizzata dall'utente \href{https://github.com/Rogach}{Rogach}.\\
L'utilizzo di \textit{Scallop} è molto semplice, basta solamente definire una classe estendente \texttt{ScallopConf} e dichiarare al suo interno un numero di variabili uguale a quello dei parametri che interessa parsare da linea di comando, specificando per ciascuna di esse il tipo di dato che deve essere parsato; fatto ciò, è sufficiente istanziare un oggetto di tale classe e richiamare i metodi aventi lo stesso nome dei parametri a cui si desidera accedere, da linea di comando invece gli argomenti vanno passati seguendo lo schema "--nomevariabile valore" se si desidera inserire il parametro, non specificando nulla se lo si vuole lasciare vuoto.\\
La libreria consente un grande insieme di ulteriori configurazioni e possibilità, ma il nostro utilizzo si è limitato solamente alle procedure sopradescritte.

\subsubsection{\textbf{Core}}
All'interno del package core, ho progettato e realizzato la parte che riguardava il mazzo di gioco e il calcolo dei punteggi.
La scelta di racchiudere due concetti apparentemente diversi all'interno della stessa vista del modello non è casuale: il mio lavoro, contenuto all'interno del package \texttt{deck}, aveva come scopo quello di creare tutte le strutture e entità necessarie alla gestione della singola carta, avente quindi un numero, seme e punteggio, come previsto dalle regole del gioco.
All'intero della figura 5.4 è riportato il diagramma delle classi di dettaglio del package \texttt{deck}:
 \begin{figure}[H]
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{deckArchitecture}
	\caption{Architettura di dettaglio del package \texttt{deck}}
\end{figure}
All'interno di questo diagramma, gli elementi portanti sono:
\begin{itemize}
	
	\item{\textbf{GameDeck}}: interfaccia per esporre all'esterno del package una struttura compatta che offre tutte le funzionalità sviluppate all'interno di \texttt{deck}. Questa interfaccia mette a disposizione un mazzo di 40 carte mescolabile, divisibile in quattro liste da 10 carte ciascuna, inoltre permette di registrare il punteggio per ciascuna presa effettuata e di mantenere aggiornati i punteggi dei due team in partita.
	
	\item{\textbf{ComposedDeck}}: implementa l'interfaccia \texttt{GameDeck}, tramite il pattern \texttt{Composite}, combinando un oggetto di classe \texttt{SimpleDeck} con uno di classe \texttt{ScoreCounter}
	
	\item{\textbf{SimpleDeck}}: mantiene una sequenza di quaranta carte di cui può variare l'ordine o andare a suddividere in quattro liste da 10 carte ciascuna, ovvero le mani dei giocatori.
	
	\item{\textbf{ScoreCounter}}: classe necessaria al mantenimento in memoria dei punteggi dei due team che stanno giocando la partita. Si appoggia a una tupla binaria composta da oggetti di classe 
	interna chiamata \texttt{ScoreTracker} a cui viene delegato il calcolo del punteggio guadagnato dal singolo team. Al fine di rispettare al massimo il principio \textit{DRY} ogni interazione tra la tupla di \texttt{ScoreTracker} e \texttt{ScoreCounter} avviene tramite un metodo privato interno chiamato \texttt{matchTeam}, a cui vengono passati il team su cui si deve attribuire una presa o un aumento di punteggio e una \texttt{Strategy} che specifica le operazioni da eseguire a seconda dell'evento da registrare: così la registrazione di una presa, l'attribuzione dei tre punti extra derivati da un eventuale Marafona e l'assegnamento del punto attribuito al team che ha effettuato l'ultima presa del set sono gestite in maniera agile e non ripetuta.
	
	\item{\textbf{Card}}: modella il concetto di carta di gioco, definendo un seme e un valore.
	Sono inoltre specificati due metodi booleani, \texttt{>} e \texttt{<} che confrontano il valore tra due carte secondo le regole previste dal gioco del Marafone.
	
	\item{\textbf{Seed}}: un insieme statico di oggetti che rappresentano i quattro semi possibili per ogni carta di gioco, realizzato con una \textit{sealed trait}  e quattro \textit{case objects} che la estendono.
	 
	A mio dire, questa parte tra tutte quelle realizzate da me, è sicuramente la migliore dal punto di vista della \textit{code quality}: tutte le classi realizzate infatti sono state progettate tenendo seguendo al meglio i principi di desing \textit{SOLID}, producendo quindi un codice il più possibile compatto, documentato e di facile lettura.\\
	Inoltre questo \texttt{package} risulta avere una coverage veramente ottima, grazie a un vasto insieme di test progettati appositamente per raggiungere questo risultato. 
	
	\begin{figure}[H]
		\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{deckCoverage}
		\caption{coverage del package \texttt{deck}}
	\end{figure}
	

\end{itemize}

\subsubsection{\textbf{Discovery}}
Il processo di analisi e definizione delle funzionalità e interazioni del discovery server è stato portato avanti insieme allo studente Riciputi, per quanto riguarda però il design di dettaglio e l'implementazione me ne sono occupato io nella loro totalità.
Assieme allo studente Riciputi abbiamo definito il ruolo del discovery come punto centrale del sistema, assegnandogli la funzione di registro centralizzato per l'elenco di server, partite e giocatori online, abbiamo inoltre pensato al basilare algoritmo di \textit{load balance} descritto nel paragrafo 4.4, ben consci dei limiti della nostra soluzione.\\
Passando poi ai dettagli di natura più implementativa, la maggior parte della complessità del discovery viene gestita a livello delle classi \texttt{DiscoveryServer} e \texttt{RegistryActor}, le altre tre strutture presenti nel package, \texttt{MatcheSet}, \texttt{SocialActorsMap} e\texttt{ServerMap} sono semplici wrapper per collezioni del linguaggio \textit{Scala} atte a mantenere traccia rispettivamente dell'elenco delle partite in esecuzione, la lista dei giocatori online e l'insieme dei server registrati nel sistema.
\texttt{DiscoveryServer} e \texttt{RegistryActor} sono strutturate in maniera tale da combinare assieme elementi di buon design con efficacia nello svolgere i loro compiti: la prima non fa altro che sviluppare e esporre l'insieme delle risorse REST necessaria al funzionamento del discovery; tutto ciò avviene tramite il metodo \texttt{deployAPI}, dove per ogni \textit{REST API} dichiarata all'interno dell'oggetto \texttt{DiscoveryAPI} viene definita, tramite un apposito metodo handler, la procedura da gestire in seguito alla ricezione di tale richiesta, la maggior parte delle \texttt{API} esposte non fanno altro che andare a alterare le strutture riguardanti i server e le partite in esecuzione.
Per quanto riguarda la lista dii giocatori online, ho scelto di procedere con un paradigma di comunicazione differente rispetto alle \textit{REST API}, trovandomi sempre io a sviluppare il lato client di questa funzionalità, come descriverò successivamente, ho ritenuto più opportuno evolvere la iniziale modalità di comunicazione, basata su \texttt{REST API} asincrone, in un canale \textit{Real Time} gestito da attori. Tale scelta è stata presa sulla base di voler garantire una migliore user experience agli utenti del sistema, permettendogli di visualizzare gli aggiornamenti della lista in tempo reale, dall'altro l'impatto che avrebbe avuto questo cambio nel paradigma di comunicazione sarebbe stato davvero minimale, visto che si trattava di convertire delle chiamate a risorse \textit{REST} in scambi di messaggi tra attori.\\
Il paradigma di comunicazione implementato è ancora una volta \textit{Publish Subscribe} gestito da \textit{Akka Cluster}, \texttt{RegsitryActor} riceve messaggi di aggiunta e rimozione di attori da parte dei vari \texttt{SocialActor} in esecuzione sui vari client, a ogni aggiornamento della lista interna, viene inviato un messaggio sul canale contente l'aggiornamento, i \texttt{SocialActor} online e registrati sul topic del canale lo registreranno e elaboreranno.\\
Unico nodo critico sta nel recuperare l'\texttt{ActorRef} del \texttt{RegistryActor} da parte dei \texttt{SocialActor} in esecuzione sui client: per facilitare questa operazione \texttt{DiscoveryServer} mette a disposizione una risorsa \textit{REST} che scatena l'invio di un messaggio di heartbeat a \texttt{RegistryActor} che provvede a notificare sul canale un messaggio contenente la propria \texttt{ActorRef} per permettere ai nuovi iscritti al canale di contattarlo direttamente.\\
Per quanto riguarda la parte di testing, sono stati sviluppati un discreto numero di test, nonostante per le funzionalità più avanzate come il testing delle risorse \texttt{REST} io sia ricorso a soluzioni grezze, il codice risulta con buoni valori di coverage all'interno delle proprie classi.

\subsubsection{\textbf{Client}}

        \subsection{Jacopo Riciputi}\label{subsec:riciputi}

        \clearpage

    \section{Retrospettiva}\label{sec:retrospective}

\end{document}
